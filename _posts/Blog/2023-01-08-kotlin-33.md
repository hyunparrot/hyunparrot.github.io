---
title:  "개발일지33일차" 
excerpt: "study33"

categories:
  - Coding
tags:
  - [Coding, Kotlin, Github,]

toc: true
toc_sticky: true
 
date: 2024-01-08
last_modified_at: 2024-01-08

---


## 코틀린 33일차

7주 차 월요일입니다!

오늘은 6주차 과제에 집중 할 예정입니다.

피드백 고쳐야 할점

1. 깃 익숙해지기
  
2. UI 좀 더 꾸미기  -----**오늘할일!**

3. 비밀번호가 틀릴 때 뜨는 Toast 메시지 조금 더 정갈하게 바꾸기

4. 버튼과 버튼 여백 사이  -----**오늘할일!**

5. 글자 크기  -----**오늘할일!**

6. 폰트  -----**오늘할일!**

7. 유효성검사 메시지 배치에 조금 더 신경쓰기 (ex. 비밀번호 적는 칸 안 쪽에 hint 형식으로 넣기)

8. 메인화면부터 띄운 다음에 로그인화면으로 넘어가는 부분은 좋았음 (어떤 앱인지 먼자 파악할 수 있어서)

## 숙련 과제 

# 어댑터 뷰 (Adapter View)

### [수업 목표]

- **어댑터 뷰의 기본 개념 및 종류를 이해한다.**
- **리스트 뷰의 설정 방법을 이해한다.**
- **그리드 뷰의 설정 방법을 이해한다.**
- **커스텀 항목 뷰를 정의하는 방법을 이해한다.**
- **RecyclerView를 사용하는 방법을 이해한다.**


### 어댑터 뷰(AdapterView)개요

### 01.❓과연 어댑터뷰는 무엇일까?

- **어댑터 뷰는 여러개의 항목을 다양한 형식으로 나열하고 선택 할 수 있는 기능을 제공하는뷰**
  
    - **리스트뷰(ListView)는 항목을 수직으로 나열시키는 방식**
      
    - **그리드뷰(GridView)는 항목을 격자 형태로 나열시키는 방식**

 어댑터 뷰는 표시할 항목 데이터를 직접 관리하지 않고,어댑터라는 객체로부터 공급받는다.
      
### 02. 어댑터 (Adapter)

**어댑터 뷰는 기본적으로 데이터 소스와 뷰를 연결하는 역할을 한다.**

**데이터 소스로부터 데이터를 가져와 각 항목을 표시하고,**

**이를 사용자에게 제공하는 역할을 수행한다.** 

요악하면, 

**데이터를 관리하며 데이터 원본과 어댑터뷰(ListView, GridView) 사이의 중계 역할**

주요 역할과 사용 예시:

**1. 데이터 관리: 어댑터는 데이터 소스(예: 배열, 리스트, 데이터베이스 등)에서 데이터를 가져와서 특정한 뷰에 표시할 수 있는 형태로 가공하고 관리한다.**

**2. 뷰 생성 및 재활용: 어댑터는 각각의 데이터 항목에 대한 뷰를 생성하고, 화면에 표시한다.**

**또한, 스크롤이나 다른 상황에서 뷰를 효율적으로 재활용하여 성능을 향상시킨다.**

**3. 이벤트 처리: 사용자의 상호 작용에 대한 이벤트(클릭, 롱클릭 등)를 처리하고,**

**해당 이벤트에 따라 필요한 작업을 수행한다.**

## 다이얼로그

**1. 기본 다이얼로그**

    binding.btn1Alert.setOnClickListener {
            var builder = AlertDialog.Builder(this)
            builder.setTitle("기본 다이얼로그 타이틀")
            builder.setMessage("기본 다이얼로그 메세지")
            builder.setIcon(R.mipmap.ic_launcher)

            // 버튼 클릭시에 무슨 작업을 할 것인가!
            val listener = object : DialogInterface.OnClickListener {
                override fun onClick(p0: DialogInterface?, p1: Int) {
                    when (p1) {
                        DialogInterface.BUTTON_POSITIVE ->
                            binding.tvTitle.text = "BUTTON_POSITIVE"
                        DialogInterface.BUTTON_NEUTRAL ->
                            binding.tvTitle.text = "BUTTON_NEUTRAL"
                        DialogInterface.BUTTON_NEGATIVE ->
                            binding.tvTitle.text = "BUTTON_NEGATIVE"
                    }
                }
            }

            builder.setPositiveButton("Positive", listener)
            builder.setNegativeButton("Negative", listener)
            builder.setNeutralButton("Neutral", listener)

            builder.show()
        }


**커스텀다이얼로그는 TEXT를 커스텀 할수있다.**

다이얼로그와 다른점은 

**2. 커스텀 다이얼로그**

        binding.btn2Custom.setOnClickListener {
            val builder = AlertDialog.Builder(this)
            builder.setTitle("커스텀 다이얼로그")
            builder.setIcon(R.mipmap.ic_launcher)

            val v1 = layoutInflater.inflate(R.layout.dialog, null)
            builder.setView(v1)

            // p0에 해당 AlertDialog가 들어온다. findViewById를 통해 view를 가져와서 사용
            val listener = DialogInterface.OnClickListener { p0, p1 ->
                val alert = p0 as AlertDialog
                val edit1: EditText? = alert.findViewById<EditText>(R.id.editText)
                val edit2: EditText? = alert.findViewById<EditText>(R.id.editText2)

                binding.tvTitle.text = "이름 : ${edit1?.text}"
                binding.tvTitle.append(" / 나이 : ${edit2?.text}")
            }

            builder.setPositiveButton("확인", listener)
            builder.setNegativeButton("취소", null)

            builder.show()
        }


    val v1 = layoutInflator.inflate(R.layout.dialog, null)
    builder.setView(v1) 

**이 들어가고 나머진 같다.**

**커스텀 다이얼로그에 "append"는 뒤에 붙인다는 얘기.**

**3. 날짜 다이얼로그**

        binding.btn3Date.setOnClickListener {
            val calendar = Calendar.getInstance()
            val year = calendar.get(Calendar.YEAR)
            val month = calendar.get(Calendar.MONTH)
            val day = calendar.get(Calendar.DAY_OF_MONTH)

            val listener = DatePickerDialog.OnDateSetListener { datePicker, i, i2, i3 ->
                // i년 i2월 i3일
                binding.tvTitle.text = "${i}년 ${i2 + 1}월 ${i3}일"
            }

            var picker = DatePickerDialog(this, listener, year, month, day)
            picker.show()
        }

**아무 날짜나 가져올 수 없으니 Calendar가 날짜를 가져오고,**

**그 안에서 날짜를 또 선택가능**

**4. 시간 다이얼로그**

        binding.btn4Time.setOnClickListener {
            val calendar = Calendar.getInstance()
            val hour = calendar.get(Calendar.HOUR)
            val minute = calendar.get(Calendar.MINUTE)

            val listener = TimePickerDialog.OnTimeSetListener { timePicker, i, i2 ->
                binding.tvTitle.text = "${i}시 ${i2}분"
            }

            val picker = TimePickerDialog(this, listener, hour, minute, false) // true하면 24시간 제
            picker.show()
        }
        
**날짜와 비슷하게 시간 분, 등등 설정하고 picker를 show(보여달란뜻)하면 됨.**

**5. 진행 다이얼로그**

**진행 다이얼로그는 동그란 원형틀이 돌아가면서 로딩 되는 형식이다.**

**로딩중이다, 시간이걸리는 작업이다, 라는 설명이 필요한 부분이라면,**

**진행 다이얼로그를 추천함.**

두가지 예시가 있는데,

**1.**

        binding.btn5Porgress.setOnClickListener {
            // 권장하진 않지만 사용은 가능하다.
            pro = ProgressDialog.show(this, "타이틀입니다.", "메시지입니다.")

            // 핸들러를 통해서 종료 작업을 한다.
            val handler = Handler()
            val thread = Runnable { pro?.cancel() }
            handler.postDelayed(thread, 5000) // 딜레이는 5초
        }

**이 코드는 ProgressDialog 줄이 그어져 있는데, 권장하지 않는다는 뜻. 하지만 사용은 가능**

**2. 다른 방식. (커스텀과 비슷)**
   
       binding.btn5Porgress.setOnClickListener {
            val builder = AlertDialog.Builder(this)
            builder.setTitle("프로그래스바")
            builder.setIcon(R.mipmap.ic_launcher)

            val v1 = layoutInflater.inflate(R.layout.progressbar, null)
            builder.setView(v1)

            builder.show()
        }

  **이 코드는 다른 다이얼로그처럼 레이아웃 필요.**
