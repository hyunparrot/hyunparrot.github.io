---
title:  "개발일지11일차" 
excerpt: "study11"

categories:
  - Coding
tags:
  - [Coding, Kotlin, Github,]

toc: true
toc_sticky: true
 
date: 2023-12-5
last_modified_at: 2023-12-5

---


## 코틀린 10일차

2주차 화요일입니다!

월요일과 같이

오늘의 플랜은 밀린 강의를 듣고,

알고리즘 문제를 풀고,

과제를 진행 할 예정이다.


## 오버라이딩


💡 **부모 클래스의 정보를 재설계할 수 있어요**

- 설명
    - 상속받은 부모 클래스의 정보(프로퍼티)나 행위(메소드)를 재설계할 수 있어요
      
    - 주로 부모 클래스의 행위(메소드)를 재설계해요
      
    - 이러한 행위를 오버라이딩 (Overriding)이라고 해요

 
💡 **오버라이딩을 어디에 사용해요?**

- 설명
    - 공통적인 내용을 부모 클래스에서 관리하는건 좋지만, 자식 클래스의 개성을 살리고 싶어요
      
- **어차피 재설계하는거라면 상속이나 오버라이딩을 하는 이유가 있나요?**
 
    - OOP관점에서는 클래스들간의 관계를 만들고, 일관성을 유지하는 목표를 가집니다
      
    - 만약 필요한 기능이 있을때마다 별도의 이름으로 만들게된다면 일관성을 해쳐요
      
    - 프로그램에 문제가 생기지는 않지만 재사용성이 떨어져 유지보수가 어려워요

만약에, 개발하는 사람들이 몇 명 안될때는

상속 안쓸거면 공통적으로 쓰는 메소드는 이 이름(참새,비둘기등등)으로 하라고 할수있지만,

개발하는 사람이 늘어났을때 공통적인 내용들도 계속 늘어난면,

그럴때마다 사람이 기억해야되는게 너무많다.

상속에서 무슨 메소드를 쓰고있었는지 보고 따라하면서 재설계하면 더욱 일관성을 지킬수있다.


💡 **코드로 예시를 알려줄게요**

**- 예시 코드**

  **- 유용한 단축키**
      
  **- 상속받은 메소드를 오버라이딩 하고 싶을때 자식 클래스 내부에서 단축키 입력**

          [오버라이딩 단축키]
          
Control + O (Windows)

Command + O (Mac)

**- 각 개체마다 개성을 더해서 날게하고 싶어요**

**- 닭, 참새, 비둘기는 새라는 부모에서 출발했다는 관계를 만들었어요**
    
**- 하지만 fly메소드는 모두 동일한 코드를 가져요**


fun main() {
    var bird = Bird("새")
    var chicken = Chicken("닭", 2)
    var sparrow = Sparrow("참새", "갈색")
    var pigeon = Pigeon("비둘기", "서울")

    bird.fly()
    chicken.fly()
    sparrow.fly()
    pigeon.fly()
}

open class Bird(name:String) {
    var name: String = ""

    init {
        // this는 현재 클래스의 상태변수를 의미합니다
        // var name: String = ""
        this.name = name
    }

    open fun fly() {
        println("${name}은 날아요~")
    }

}

class Chicken(name: String, age: Int) : Bird(name) {
    var age:Int = 0

    init {
        this.age = age
    }

    override fun fly() {
        //super.fly()
        //super라는거는 내부적으로 상속을 받으면 자동으로 부모가 되는 객체
        //즉, bird객체에 fly 메소드를 불러라 하는것.
        //하지만 지금은 필요없기에 주석처리
        println("${age}살의 ${name}가 날아봅니다~ 꼬끼오!")
    }

    //  override fun fly() {
//        super객체는 부모의 객체를 의미하며 자동으로 생성됨
//        즉 부모객체의 fly메소드를 부르는 행위임
//        필요없으니 주석처리완료
//        super.fly()
    //     println("${age}살의 ${name}가 날아봅니다~ 꼬끼오!")
   //잠깐 바로 위에 예시를 든거라서 주석처리함.
    //  }
}

class Sparrow(name: String, color: String) : Bird(name) {
    var color:String = ""

    init {
        this.color = color
    }

    override fun fly() {
//        super객체는 부모의 객체를 의미하며 자동으로 생성됨
//        즉 부모객체의 fly메소드를 부르는 행위임
//        필요없으니 주석처리완료
//        super.fly()
        println("${color}의 ${name}이 날아봅니다~ 짹짹!")
    }
}

class Pigeon(name: String, address: String) : Bird(name) {
    var address: String = ""

    init {
        this.address = address
    }

    override fun fly() {
//        super객체는 부모의 객체를 의미하며 자동으로 생성됨
//        즉 부모객체의 fly메소드를 부르는 행위임
//        필요없으니 주석처리완료
//        super.fly()
        println("${address} 살고있는 ${name}가 날아봅니다~ 구구!")
    }
}

## 오버로딩


💡 **동일한 이름의 메소드를 여러 형태로 만들 수 있어요**

- 설명
  
    - 매개변수의 **갯수**를 다르게하면 동일한 이름으로 메소드를 만들 수 있어요
      
    - 매개변수의 **자료형**을 다르게하면 동일한 이름으로 메소드를 만들 수 있어요
      
    - 반환자료형(반환형)은 오버로딩에 영향을 주지 않아요

💡 **오버로딩을 어디에 사용해요?**



- 설명
- 
    - 두 개의 정수를 매개변수로 받아 더하는 메소드를 add라는 이름으로 만들었어요
      
    - 하지만 두 개의 실수(소수)를 매개변수로 받아 더하는 메소드도 만들어야해요
      
    - 더하는거니까 add라는 이름이 적합한데 어떻게 해야할까요?
 
      
    - 오버로딩이 없다면, addInt, addDouble 이렇게 메소드를 따로 만들어야하는데 나중에 관리하기 힘들어져요
      
    - 이 상황에서는 더해야하는 자료형이 정수,실수로 다르니까 오버로딩으로 해결할 수 있어요
 
💡 **코드로 예시를 알려줄게요**



- 예시 코드
  
    - 정수나 실수값 두개를 매개변수로 받아서 덧셈결과를 리턴해주는 add메소드를 만들어요
 
      fun main() {
    var calc = Calculator()
    
    var intResult = calc.add(1,2)
    var doubleResult = calc.add(1.2, 2.2)
    
    println("정수 덧셈결과: ${intResult}")
    println("실수 덧셈결과: ${doubleResult}")
    
}

class Calculator {
    
    fun add(num1: Int, num2: Int): Int {
        return num1+num2
    }
    
    fun add(num1: Double, num2: Double): Double {
        return num1+num2
    }
}


**알고리즘 문제**























**알고리즘 문제 복습**


**문제 설명**

임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다.

n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.

**제한 사항**

n은 1이상, 50000000000000 이하인 양의 정수입니다.


 import kotlin.math.sqrt

class Solution {
    fun solution(n: Long): Long {
        if (n < 0) return -1
        val x = sqrt(n.toDouble()).toLong()
        return if (x * x == n) (x + 1) * (x + 1) else -1
    }
}


**val x = sqrt(n.toDouble()).toLong() 에 대한 설명**

 왜 to.Double() 인가??

sqrt 함수는 Double 타입의 숫자를 필요로한다. 실수(소수점)를 포함한 제곱근을 계산하기 때문이다
.
따라서 n이 Int 타입일 경우, toDouble() 함수를 사용하여 Double 타입으로 변환한 후에 sqrt 함수를 호출한다.

만약 sqrt 함수에 Int 타입의 숫자를 바로 전달하면, 컴파일러에서는 타입 불일치 오류가 발생할 수 있다.
따라서 정확한 계산을 위해 toDouble()을 사용하여 Double 타입으로 변환하는 것이다. 최종적으로 toLong()을 호출하여 x의 값을 Long 타입으로 변환한다.

**sqrt가 뭐야?**

sqrt는 주어진 숫자의 제곱근을 계산하는 함수이다.

