---
title:  "개발일지11일차" 
excerpt: "study11"

categories:
  - Coding
tags:
  - [Coding, Kotlin, Github,]

toc: true
toc_sticky: true
 
date: 2023-12-5
last_modified_at: 2023-12-5

---


## 코틀린 10일차

2주차 화요일입니다!

월요일과 같이

오늘의 플랜은 밀린 강의를 듣고,

알고리즘 문제를 풀고,

과제를 진행 할 예정이다.


## 오버라이딩


💡 **부모 클래스의 정보를 재설계할 수 있어요**

- 설명
    - 상속받은 부모 클래스의 정보(프로퍼티)나 행위(메소드)를 재설계할 수 있어요
      
    - 주로 부모 클래스의 행위(메소드)를 재설계해요
      
    - 이러한 행위를 오버라이딩 (Overriding)이라고 해요

 
💡 **오버라이딩을 어디에 사용해요?**

- 설명
    - 공통적인 내용을 부모 클래스에서 관리하는건 좋지만, 자식 클래스의 개성을 살리고 싶어요
      
- **어차피 재설계하는거라면 상속이나 오버라이딩을 하는 이유가 있나요?**
 
    - OOP관점에서는 클래스들간의 관계를 만들고, 일관성을 유지하는 목표를 가집니다
      
    - 만약 필요한 기능이 있을때마다 별도의 이름으로 만들게된다면 일관성을 해쳐요
      
    - 프로그램에 문제가 생기지는 않지만 재사용성이 떨어져 유지보수가 어려워요

만약에, 개발하는 사람들이 몇 명 안될때는

상속 안쓸거면 공통적으로 쓰는 메소드는 이 이름(참새,비둘기등등)으로 하라고 할수있지만,

개발하는 사람이 늘어났을때 공통적인 내용들도 계속 늘어난면,

그럴때마다 사람이 기억해야되는게 너무많다.

상속에서 무슨 메소드를 쓰고있었는지 보고 따라하면서 재설계하면 더욱 일관성을 지킬수있다.


💡 **코드로 예시를 알려줄게요**

**- 예시 코드**

  **- 유용한 단축키**
      
  **- 상속받은 메소드를 오버라이딩 하고 싶을때 자식 클래스 내부에서 단축키 입력**

          [오버라이딩 단축키]
          
Control + O (Windows)

Command + O (Mac)

**- 각 개체마다 개성을 더해서 날게하고 싶어요**

**- 닭, 참새, 비둘기는 새라는 부모에서 출발했다는 관계를 만들었어요**
    
**- 하지만 fly메소드는 모두 동일한 코드를 가져요**


fun main() {
    var bird = Bird("새")
    var chicken = Chicken("닭", 2)
    var sparrow = Sparrow("참새", "갈색")
    var pigeon = Pigeon("비둘기", "서울")

    bird.fly()
    chicken.fly()
    sparrow.fly()
    pigeon.fly()
}

open class Bird(name:String) {
    var name: String = ""

    init {
        // this는 현재 클래스의 상태변수를 의미합니다
        // var name: String = ""
        this.name = name
    }

    open fun fly() {
        println("${name}은 날아요~")
    }

}

class Chicken(name: String, age: Int) : Bird(name) {
    var age:Int = 0

    init {
        this.age = age
    }

    override fun fly() {
        //super.fly()
        //super라는거는 내부적으로 상속을 받으면 자동으로 부모가 되는 객체
        //즉, bird객체에 fly 메소드를 불러라 하는것.
        //하지만 지금은 필요없기에 주석처리
        println("${age}살의 ${name}가 날아봅니다~ 꼬끼오!")
    }

    //  override fun fly() {
//        super객체는 부모의 객체를 의미하며 자동으로 생성됨
//        즉 부모객체의 fly메소드를 부르는 행위임
//        필요없으니 주석처리완료
//        super.fly()
    //     println("${age}살의 ${name}가 날아봅니다~ 꼬끼오!")
   //잠깐 바로 위에 예시를 든거라서 주석처리함.
    //  }
}

class Sparrow(name: String, color: String) : Bird(name) {
    var color:String = ""

    init {
        this.color = color
    }

    override fun fly() {
//        super객체는 부모의 객체를 의미하며 자동으로 생성됨
//        즉 부모객체의 fly메소드를 부르는 행위임
//        필요없으니 주석처리완료
//        super.fly()
        println("${color}의 ${name}이 날아봅니다~ 짹짹!")
    }
}

class Pigeon(name: String, address: String) : Bird(name) {
    var address: String = ""

    init {
        this.address = address
    }

    override fun fly() {
//        super객체는 부모의 객체를 의미하며 자동으로 생성됨
//        즉 부모객체의 fly메소드를 부르는 행위임
//        필요없으니 주석처리완료
//        super.fly()
        println("${address} 살고있는 ${name}가 날아봅니다~ 구구!")
    }
}

## 오버로딩


💡 **동일한 이름의 메소드를 여러 형태로 만들 수 있어요**

- 설명
  
    - 매개변수의 **갯수**를 다르게하면 동일한 이름으로 메소드를 만들 수 있어요
      
    - 매개변수의 **자료형**을 다르게하면 동일한 이름으로 메소드를 만들 수 있어요
      
    - 반환자료형(반환형)은 오버로딩에 영향을 주지 않아요

💡 **오버로딩을 어디에 사용해요?**



- 설명
- 
    - 두 개의 정수를 매개변수로 받아 더하는 메소드를 add라는 이름으로 만들었어요
      
    - 하지만 두 개의 실수(소수)를 매개변수로 받아 더하는 메소드도 만들어야해요
      
    - 더하는거니까 add라는 이름이 적합한데 어떻게 해야할까요?
 
      
    - 오버로딩이 없다면, addInt, addDouble 이렇게 메소드를 따로 만들어야하는데 나중에 관리하기 힘들어져요
      
    - 이 상황에서는 더해야하는 자료형이 정수,실수로 다르니까 오버로딩으로 해결할 수 있어요
 
💡 **코드로 예시를 알려줄게요**



- 예시 코드
  
    - 정수나 실수값 두개를 매개변수로 받아서 덧셈결과를 리턴해주는 add메소드를 만들어요
 
      fun main() {
    var calc = Calculator()
    
    var intResult = calc.add(1,2)
    var doubleResult = calc.add(1.2, 2.2)
    
    println("정수 덧셈결과: ${intResult}")
    println("실수 덧셈결과: ${doubleResult}")
    
}

class Calculator {
    
    fun add(num1: Int, num2: Int): Int {
        return num1+num2
    }
    
    fun add(num1: Double, num2: Double): Double {
        return num1+num2
    }
}


=>
정수 덧셈결과: 3
실수 덧셈결과: 3.4000000000000004

## 인터페이스

💡 **공통적으로 필요한 기능을 외부에서 추가해줄 수 있어요**

- 설명
  
    **- 문제**
      
        - 앞서 상속으로 닭, 참새, 비둘기와 부모 클래스인 Bird의 관계를 만들었어요
          
        - 하지만 새에도 많은 종류가 있고, 고유한 행동도 달라요
          
        - 코틀린은 반드시 부모 클래스는 한개라서 모두 상속으로 처리할 수 없어요
          
    **- 해결**
      
        - 따라서 근본적인 공통점을 상속 받고, 추가적인 기능들은 인터페이스로 추가해요
          
        - 코틀린은 인터페이스를 만들기 위해 interface 키워드를 사용해요

**Kotlin의 인터페이스 구조**

아래의 예시처럼 메소드의 로직이 존재하지않고 이름만 존재할때 추상 메소드라고 해요

원래 인터페이스는 추상메소드만 허용하지만 최근에는 추상메소드가 아니여도 괜찮아요

하지만 인터페이스는 추상메소드를 작성하는 습관을 가지는게 좋아요!


interface 인터페이스이름 {
	fun 메소드이름()
}


💡 **인터페이스를 어디에 사용해요?**

- 설명
    - 상속으로 클래스들간의 관계를 성공적으로 구분했어요
    - 
    - 닭, 참새, 비둘기까지는 문제없지만 오리가 추가된다면 고민이 생겨요
    - 
    - 보통 새는 **헤엄치다**라는 행위가 없기 때문에 부모 클래스에 추가하는 것은 올바르지 않아요
    - 
    - 오리를 제외하고도 물에서 서식하는 조류는 별도의 기능이 필요해요
 
    - 근본적인것은 그냥 조류이고 물에서 서식하는 조류의 행위는 근본적인 공통점이 아니기때문에 인터페이스로 뺌
 
   
💡 **코드로 예시를 알려줄게요**



- 예시 코드
- 
  **new -> kotlin class/file ->  interface WaterBirdBehavior**

    **- WaterBirdBehavior.kt**
 
      interface WaterBirdBehavior {
    fun swim()
//    fun swim() {
//        println("수영 합니다")
//    }
}

- fun swim() swim 안에 내용이 없는걸로 두는게 **추상메소드**라고 하는데,

- 어차피 이 메소드를 그 해당하는 클래스에서 받아서 오버라이딩 할거기때문에

- 굳이 여기서 수영 합니다 라는걸 둘 이유가 없다
  
**Test.kt**

fun main() {
    var bird = Bird("새")
    var chicken = Chicken("닭")
    var sparrow = Sparrow("참새")
    var pigeon = Pigeon("비둘기")
    var duck = Duck("오리")

    bird.fly()
    chicken.fly()
    sparrow.fly()
    pigeon.fly()
    duck.swim()
}

open class Bird(name:String) {
    var name: String = ""

    init {
        // this는 현재 클래스의 상태변수를 의미합니다
        // var name: String = ""
        this.name = name
    }

    fun fly() {
        println("${name} 날아요~")
    }

}

class Chicken(name: String) : Bird(name) {

}

class Sparrow(name: String) : Bird(name) {

}

class Pigeon(name: String) : Bird(name) {

}

class Duck(name: String) : Bird(name), WaterBirdBehavior {
    override fun swim() {
        println("${name}가 수영해요~")
    }
}

=>

새 날아요~
닭 날아요~
참새 날아요~
비둘기 날아요~
오리가 수영해요~

정리하면, 오리는 조류이면서 물에서 사는 조류를 나타내기 때문에

물에서 사는 조류의 행동을 

인터페이스로 추가적으로 넣어줬음.

**알고리즘 문제**























**알고리즘 문제 복습**


**문제 설명**

임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다.

n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.

**제한 사항**

n은 1이상, 50000000000000 이하인 양의 정수입니다.


 import kotlin.math.sqrt

class Solution {
    fun solution(n: Long): Long {
        if (n < 0) return -1
        val x = sqrt(n.toDouble()).toLong()
        return if (x * x == n) (x + 1) * (x + 1) else -1
    }
}


**val x = sqrt(n.toDouble()).toLong() 에 대한 설명**

 왜 to.Double() 인가??

sqrt 함수는 Double 타입의 숫자를 필요로한다. 실수(소수점)를 포함한 제곱근을 계산하기 때문이다
.
따라서 n이 Int 타입일 경우, toDouble() 함수를 사용하여 Double 타입으로 변환한 후에 sqrt 함수를 호출한다.

만약 sqrt 함수에 Int 타입의 숫자를 바로 전달하면, 컴파일러에서는 타입 불일치 오류가 발생할 수 있다.
따라서 정확한 계산을 위해 toDouble()을 사용하여 Double 타입으로 변환하는 것이다. 최종적으로 toLong()을 호출하여 x의 값을 Long 타입으로 변환한다.

**sqrt가 뭐야?**

sqrt는 주어진 숫자의 제곱근을 계산하는 함수이다.

